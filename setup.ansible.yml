---
  - name: Collecting information and checking system
    hosts: localhost
    connection: local
    vars:
      ARCHITECTURE_ALIAS:
        x86_64: amd64
      REQUIRED_PPAS:
        # Git
        - ppa: ppa:git-core/ppa
          filename: git-core-ubuntu-ppa
        # Ansible
        - ppa: ppa:ansible/ansible
          filename: ansible-ubuntu-ansible
      REQUIRED_APT_KEYRINGS:
        - google-chrome
      CONTAINERIZATION_APT_KEYRINGS:
        - docker
        - microsoft
        - kubernetes-archive-keyring
      REQUIRED_REPOSITORIES:
        google-chrome: deb [arch={{ ARCHITECTURE }}] https://dl.google.com/linux/chrome/deb/ stable main
      CONTAINERIZATION_REPOSITORIES:
        docker: deb [arch={{ ARCHITECTURE }} signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu {{ ansible_facts['distribution_release'] }} stable
        kubernetes: deb [signed-by=/etc/apt/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main
        azure-cli: deb [arch={{ ARCHITECTURE }} signed-by=/etc/apt/keyrings/microsoft.gpg] https://packages.microsoft.com/repos/azure-cli/ {{ ansible_facts['distribution_release'] }} main
      REQUIRED_PACKAGES:
        - google-chrome-stable
      JAVA_PACKAGES:
        - default-jdk
        - default-jdk-doc
        - maven
      CONTAINERIZATION_PACKAGES:
        # Docker
        - docker-ce
        - docker-ce-cli
        - containerd.io
        - docker-buildx-plugin
        - docker-compose-plugin
        # Kubernetes
        - kubectl
        # Azure CLI
        - azure-cli
      REQUIRED_SYSTEMD_SERVICES:
        - unattended-upgrades
        - snapd
      CONTAINERIZATION_SERVICES:
        - docker.service
        - containerd.service
      REQUIRED_SNAPS:
        - firefox
      JAVA_CLASSIC_SNAPS:
        - intellij-idea-community
      CONTAINERIZATION_CLASSIC_SNAPS:
        - helm
      REQUIRED_CONFIGURATION_FILES:
        # Geany
        - template: geany.conf
          target_filename: geany.conf
          target_directory: ~/.config/geany
        - template: geany.addons.conf
          target_filename: addons.conf
          target_directory: ~/.config/geany/plugins/addons
        - template: geany.autoclose.conf
          target_filename: autoclose.conf
          target_directory: ~/.config/geany/plugins/autoclose
        - template: geany.git-changebar.conf
          target_filename: git-changebar.conf
          target_directory: ~/.config/geany/plugins/git-changebar
        - template: geany.overview.conf
          target_filename: prefs.conf
          target_directory: ~/.config/geany/plugins/overview
        - template: geany.spellcheck.conf
          target_filename: spellcheck.conf
          target_directory: ~/.config/geany/plugins/spellcheck
        # Enchant
        - template: enchant_dictionary_en_US
          target_filename: en_US.dic
          target_directory: ~/.config/enchant

    tasks:

      - name: Exiting if we are not running Ubuntu
        ansible.builtin.fail:
          msg: "The OS is {{ ansible_facts['distribution'] }}. This playbook is only meant to work with Ubuntu."
        when: ansible_facts['distribution'] != "Ubuntu"

      - name: Populating service facts
        ansible.builtin.service_facts:

      - name: Setting system variables
        ansible.builtin.set_fact:
          ARCHITECTURE: "{{ ARCHITECTURE_ALIAS[ansible_facts['architecture']] }}"
          HOSTNAME: "{{ (ansible_facts['distribution'] + '-' + ansible_facts['distribution_version']) | replace('.', '-') }}"
          CURRENT_DIRECTORY: "{{ ansible_facts['env']['PWD'] }}"
          SYSTEMD_IS_RUNNING: "{{ 'systemd-logind.service' in ansible_facts['services'] }}"
          CONTAINERIZATION_TECHS: "{{ INSTALL_CONTAINERIZATION_TECHS is defined and INSTALL_CONTAINERIZATION_TECHS == 'true' }}"

      - name: Exiting if we were not able to determine the architecture
        ansible.builtin.fail:
          msg: "Can't find an alias for architecture '{{ ansible_facts['architecture'] }}'."
        when: ansible_facts['architecture'] not in ARCHITECTURE_ALIAS

      - name: Setting playbook variables
        ansible.builtin.set_fact:
          PPAS: '{{ REQUIRED_PPAS }}'
          APT_KEYRINGS: >
            {{ REQUIRED_APT_KEYRINGS +
            (CONTAINERIZATION_APT_KEYRINGS if CONTAINERIZATION_TECHS else []) }}
          REPOSITORIES: >
            {{ dict(REQUIRED_REPOSITORIES,
            **(CONTAINERIZATION_REPOSITORIES if CONTAINERIZATION_TECHS else {})) }}
          ADDITIONAL_PACKAGES: >
            {{ REQUIRED_PACKAGES + JAVA_PACKAGES +
            (CONTAINERIZATION_PACKAGES if CONTAINERIZATION_TECHS else []) }}
          SYSTEMD_SERVICES: >
            {{ REQUIRED_SYSTEMD_SERVICES +
            (CONTAINERIZATION_SERVICES if CONTAINERIZATION_TECHS else []) }}
          SNAPS: '{{ REQUIRED_SNAPS }}'
          CLASSIC_SNAPS: >
            {{ JAVA_CLASSIC_SNAPS +
            (CONTAINERIZATION_CLASSIC_SNAPS if CONTAINERIZATION_TECHS else []) }}
          CONFIGURATION_FILES: '{{ REQUIRED_CONFIGURATION_FILES }}'

  - name: Systemwide changes
    hosts: localhost
    connection: local
    become: yes

    tasks:

      - name: Adding PPAs
        ansible.builtin.command:
          cmd: /usr/bin/add-apt-repository --yes "{{ item['ppa'] }}"
          creates: /etc/apt/sources.list.d/{{ item['filename'] }}-{{ ansible_facts['distribution_release'] }}.list
        loop: '{{ PPAS }}'

      - name: Updating system
        ansible.builtin.apt:
          update_cache: yes
          upgrade: full
        tags: update

      - name: Installing packages
        ansible.builtin.apt:
          cache_valid_time: 600
          update_cache: yes
          install_recommends: yes
          name:
            - ansible
            - gnupg
            - ca-certificates
            - coreutils
            - bash-completion
            - aptitude
            - unattended-upgrades
            - snapd
            - git
            - openssh-client
            - joe
            - bat
            - mc
            - ncdu
            - fd-find
            - ytree
            - tofrodos
            - python3-pip
            - finger
            - htop
            - colordiff
            - build-essential
            - cmake
            - p7zip-full
            - makepasswd
            - neofetch
            - screenfetch
            # Fonts
            - fonts-noto
            - fonts-recommended
            - fonts-cascadia-code
            - fonts-droid-fallback
            - fonts-firacode
            - fonts-font-awesome
            - fonts-fork-awesome
            - fonts-monoid
            - fonts-monoid-halfloose
            - fonts-monoid-halftight
            - fonts-monoid-loose
            - fonts-monoid-tight
            - fonts-liberation
            - fonts-inconsolata
            # GUI applications
            - gitk
            - geany
            - geany-plugins
            - adwaita-icon-theme-full
            - meld
            - gpa
            - font-manager
          state: latest
        tags: install

      - name: Creating directory /etc/apt/keyrings if it does not exist
        ansible.builtin.file:
          path: /etc/apt/keyrings
          state: directory
          mode: u=rwx,g=rx,o=rx

      - name: Removing Mozilla Firefox deb package
        ansible.builtin.apt:
          name: firefox
          state: absent
        when: SYSTEMD_IS_RUNNING

      - name: Removing old versions of Docker
        ansible.builtin.apt:
          name:
            - docker
            - docker-engine
            - docker.io
            - containerd
            - runc
          state: absent
        when: CONTAINERIZATION_TECHS

      - name: Adding GPG keys from apt_keyrings
        ansible.builtin.shell:
          cmd: /usr/bin/gpg --dearmor --output /etc/apt/keyrings/{{ item }}.gpg <./apt_keyrings/{{ item }}.txt
          creates: /etc/apt/keyrings/{{ item }}.gpg
          executable: /bin/bash
        loop: '{{ APT_KEYRINGS }}'

      - name: Ensuring GPG keys have correct permissions
        ansible.builtin.file:
          path: /etc/apt/keyrings/{{ item }}.gpg
          mode: u=rw,g=r,o=r
        loop: '{{ APT_KEYRINGS }}'

      # Google Chrome needs its GPG key in /etc/apt/trusted.gpg.d/.
      # Hopefully, this will change.
      - name: Copying google-chrome.gpg to /etc/apt/trusted.gpg.d/
        ansible.builtin.copy:
          src: /etc/apt/keyrings/google-chrome.gpg
          dest: /etc/apt/trusted.gpg.d/google-chrome.gpg
          mode: u=rw,g=r,o=r
          remote_src: yes

      - name: Adding repositories
        ansible.builtin.apt_repository:
          repo: "{{ item.value }}"
          filename: "{{ item.key }}"
          update_cache: no
        with_dict: "{{ REPOSITORIES }}"

      - name: Installing additional packages
        ansible.builtin.apt:
          update_cache: yes
          install_recommends: yes
          name: '{{ ADDITIONAL_PACKAGES }}'
          state: latest

      - name: Cleaning the local apt cache
        ansible.builtin.apt:
          autoclean: yes

      - name: Ensuring group docker exists
        ansible.builtin.group:
          name: docker
          state: present
        when: CONTAINERIZATION_TECHS

      - name: Adding the user to the docker group
        ansible.builtin.user:
          name: "{{ ansible_facts['env']['SUDO_USER'] }}"
          groups: docker
          append: yes
        notify: "reboot required"
        register: ADD_USER_TO_DOCKER_OUTPUT
        when: CONTAINERIZATION_TECHS

      - name: Starting services if they are not running
        ansible.builtin.service:
          name: '{{ item }}'
          state: started
          enabled: yes
        with_items: '{{ SYSTEMD_SERVICES }}'
        when: SYSTEMD_IS_RUNNING

      - name: Updating existing snaps
        block:
          - name: Checking for snaps to update
            ansible.builtin.command:
              cmd: /usr/bin/snap refresh --list
            register: SNAPS_TO_UPDATE
            changed_when: false
            tags: snap

          - name: Refreshing snaps
            ansible.builtin.command:
              cmd: /usr/bin/snap refresh
            tags: snap
            when: SNAPS_TO_UPDATE['stdout_lines'] | length >= 2
        when: SYSTEMD_IS_RUNNING

      - name: Installing snaps
        community.general.snap:
          name: '{{ item }}'
        loop: '{{ SNAPS }}'
        tags: snap
        when: SYSTEMD_IS_RUNNING

      - name: Installing classic snaps
        community.general.snap:
          name: '{{ item }}'
          classic: true
        loop: '{{ CLASSIC_SNAPS }}'
        tags: snap
        when: SYSTEMD_IS_RUNNING

      - name: Creating /etc/wsl.conf from template wsl.conf.j2
        ansible.builtin.template:
          src: ./templates/wsl.conf.j2
          dest: /etc/wsl.conf
          mode: u=rw,g=r,o=r
        notify: "reboot required"
        tags: wsl.conf

    handlers:
      - name: Touching /var/run/reboot-required
        ansible.builtin.file:
          path: /var/run/reboot-required
          state: touch
          mode: u=rw,g=r,o=r
        listen: "reboot required"

  - name: Setting up the environment for the current user
    hosts: localhost
    connection: local
    tags: user
    vars:
      SSH_KEY_FILENAME: "id_ed25519.git"
      SSH_KEY_FINGERPRINTS: [
        "github.com ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIOMqqnkVzrm0SdG6UOoqKLsabgH5C9okWi0dh2l9GKJl",
        "github.com ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBEmKSENjQEezOmxkZMy7opKgwFB9nkt5YRrYMjNuG5N87uRgg6CLrbo5wAdT/y6v0mKV0U2w0WZ2YB/++Tpockg=",
        "github.com ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAq2A7hRGmdnm9tUDbO9IDSwBK6TbQa+PXYPCPy6rbTrTtw7PHkccKrpp0yVhp5HdEIcKr6pLlVDBfOLX9QUsyCOV0wzfjIJNlGEYsdlLJizHhbn2mUjvSAHQqZETYP81eFzLQNnPHt4EVVUh7VfDESU84KezmD5QlWpXLmvU31/yMf+Se8xhHTvKSCZIFImWwoG6mbUoWf9nzpIoaSjB+weqqUUmpaaasXVal72J+UX2B+2RPW3RcT0eOzQgqlJL3RKrTJvdsjE3JEAvGq3lGHSZXy28G3skua2SmVi/w4yCE6gbODqnTWlg7+wC604ydGXA8VJiS5ap43JXiUFFAaQ=="
      ]

    tasks:

      - name: Exiting if FULLNAME or EMAIL are not defined
        ansible.builtin.fail:
          msg: "Required variables FULLNAME or EMAIL are not defined."
        when: (FULLNAME is undefined) or (EMAIL is undefined)

      - name: Creating directory ~/.ssh/ if it does not exist
        ansible.builtin.file:
          path: ~/.ssh/
          state: directory
          mode: u=rwx,g=,o=
        tags: ssh

      - name: Generating a GitHub recommended SSH key if it doesn't exist
        community.crypto.openssh_keypair:
          path: ~/.ssh/{{ SSH_KEY_FILENAME }}
          type: ed25519
          comment: "{{ EMAIL }}"
          regenerate: partial_idempotence
        tags: ssh

      - name: Creating ~/.ssh/config from template ssh_client_config.j2
        ansible.builtin.template:
          src: ./templates/ssh_client_config.j2
          dest: ~/.ssh/config
          mode: u=rw,g=,o=
          backup: yes
        tags: ssh

      - name: Adding SSH key fingerprints to ~/.ssh/known_hosts
        ansible.builtin.lineinfile:
          path: ~/.ssh/known_hosts
          line: '{{ item }}'
          mode: u=rw,g=,o=
          create: yes
        with_items: '{{ SSH_KEY_FINGERPRINTS }}'
        tags: ssh

      - name: Setting up GPG
        ansible.builtin.command:
          cmd: ./scripts/setup_gpg.sh "{{ FULLNAME }}" "{{ EMAIL }}"
          creates: ~/.gnupg
        register: GPG_OUTPUT
        tags: gpg

      - name: Printing the output of GPG setup
        ansible.builtin.debug:
          var: GPG_OUTPUT['stdout_lines']
        tags: gpg

      - name: Creating ~/bash_profile.sh from template bash_profile.sh.j2
        ansible.builtin.template:
          src: ./templates/bash_profile.sh.j2
          dest: ~/bash_profile.sh
          mode: u=rwx,g=r,o=r
        tags: bash_profile.sh

      - name: Adding a line to ~/.bashrc to run ~/bash_profile.sh
        ansible.builtin.lineinfile:
          path: ~/.bashrc
          line: . ~/bash_profile.sh
          backup: yes
        tags: bash_profile.sh

      - name: Creating directories for configuration files
        ansible.builtin.file:
          path: "{{ item['target_directory'] }}"
          state: directory
          mode: u=rwx,g=,o=
        loop: '{{ CONFIGURATION_FILES }}'

      - name: Creating configuration files from templates
        ansible.builtin.template:
          src: ./templates/{{ item['template'] }}.j2
          dest: "{{ item['target_directory'] }}/{{ item['target_filename'] }}"
          mode: u=rw,g=,o=
          force: no
        loop: '{{ CONFIGURATION_FILES }}'

      - name: Setting the full name in /etc/passwd
        ansible.builtin.command: /usr/bin/chfn --full-name "{{ FULLNAME }}" {{ ansible_facts['user_id'] }}
        become: yes
        ignore_errors: yes
        when: FULLNAME != (ansible_facts['user_gecos'] | split(','))[0]

      - name: Installing docker python package
        ansible.builtin.pip:
          name: docker
          extra_args: --upgrade
          executable: /usr/bin/pip3
        when: CONTAINERIZATION_TECHS

      - name: Verifying that the user can run docker commands
        block:
          - name: Inspecting if image hello-world is present
            community.docker.docker_image_info:
              name: hello-world
            register: DOCKER_IMAGE_OUTPUT

          - name: Executing "docker run hello-world"
            ansible.builtin.command:
              cmd: /usr/bin/docker run hello-world
            register: DOCKER_RUN_OUTPUT
            when: DOCKER_IMAGE_OUTPUT['images'] | length == 0

          - name: Printing the output of "docker run hello-world"
            ansible.builtin.debug:
              var: DOCKER_RUN_OUTPUT['stderr_lines'] + DOCKER_RUN_OUTPUT['stdout_lines']
            when: DOCKER_RUN_OUTPUT['changed']
        when: CONTAINERIZATION_TECHS and SYSTEMD_IS_RUNNING and not ADD_USER_TO_DOCKER_OUTPUT['changed']

      - name: Printing message about systemd
        ansible.builtin.debug:
          msg: It seems that Ubuntu was not started with systemd. This means that some tasks were skipped. Run 'run_install_script' after restarting WSL.
        when: not SYSTEMD_IS_RUNNING

      - name: Printing message about Docker
        ansible.builtin.debug:
          msg: Docker was installed. In order to verify that the user can run docker commands, run 'run_install_script' after restarting WSL.
        when: ADD_USER_TO_DOCKER_OUTPUT['changed']
